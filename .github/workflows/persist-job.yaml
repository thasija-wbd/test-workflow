name: Persist Job

on:
  workflow_call:
    inputs:
      matrix:
        required: true
        description: The matrix of infrastructure deployments to build with Terragrunt.
        type: string
      files:
        required: false
        description: The map of feature flags set in the workflow spec.
        type: string
      action:
        required: false
        description: >
          Sets the maximum number of parallel Terragrunt actions to execute. If your deployments
          have any dependencies on each other, then set this to 1.
        type: string
        default: 1
      count:
        required: false
        default: ""
        description: >
          A map of key:value pairs that are used to inject extra secrets into the GitHub environment.
          The key is mapped as the environment variable name, and the value is used as the value to assign
          to that variable from the secrets.
        type: string

jobs:
  apply:
    name: Apply
    runs-on: ubuntu-latest
    if: ${{inputs.count != 0}}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 2
      - name: Configure AWS creds
        uses: aws-actions/configure-aws-credentials@v3
        with:
          role-to-assume: arn:aws:iam::076787413861:role/test-iam
          role-session-name: deploysession
          aws-region: us-east-1
      - name: Transform yaml to Json
        env:
          FILES: ${{ inputs.files }}
        id: transform-yaml-to-json
        run: |
          files=()
          for FILE in $FILES; do
            trimmed_file=$(echo "$FILE" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')
            json_file="${FILE%.yml}.json"
            yq -o=json "$trimmed_file" > "$json_file"
            echo "Converted JSON content saved to $json_file"
            echo "$(cat "$json_file")" 
            files+=("$json_file")
          done
          echo "json_files=${files[@]}" >> $GITHUB_OUTPUT
      - name: Call the lambda function
        env:
          ACTION: ${{inputs.action}}
        id: parse-payload
        run: |
          payload_files=()
          if [[ -n "${{ steps.transform-yaml-to-json.outputs.json_files }}" ]]; then
            IFS=' ' read -ra updated_files <<< "${{ steps.transform-yaml-to-json.outputs.json_files }}"
            for file in "${updated_files[@]}"; do
              json_content=$(cat "$file")
              action_type="$ACTION"
              event_payload=$(echo "$json_content" | jq -c '{"action": "'"$action_type"'", "payload": '"$json_content"'}')
              payload_files+=("$event_payload")
            done
          fi
          # API CALL
          for payload_file in "${payload_files[@]}"; do
            aws lambda invoke \
              --function-name test-function \
              --cli-binary-format raw-in-base64-out \
              --payload "${payload_file}" \
              response.json
          done
