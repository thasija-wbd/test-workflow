name: Lamda invoke Job

on:
  push:
    branches:
      - main
    paths:
      - job-definitions/**
permissions: write-all

jobs:
  checkout-step:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Get changed files
        id: changed-files
        uses: tj-actions/changed-files@v40
        with:
          files: job-definitions/**

      - name: List all added files
        run: |
          for file in ${{steps.changed-files.outputs.added_files}}; do
          echo "$file was added"
          done

          for file in ${{ steps.changed-files.outputs.modified_files }}; do
          echo "$file was modified"
          done
      - name: Transform yaml to Json
        id: transform-yaml-to-json
        run: |
          echo Transform files
          added_files=()
          modified_files=()
          if [[ -n "${{ steps.changed-files.outputs.added_files }}" ]]; then
          for file in ${{ steps.changed-files.outputs.added_files }}; do
          json_content=$(yq eval "$file" -o=json)            
          json_file="${file%.yml}.json"
          echo "$json_content" > "$json_file"
          added_files+=("$json_file")
          done
          fi
          if [[ -n "${{ steps.changed-files.outputs.modified_files }}" ]]; then
          for file in ${{ steps.changed-files.outputs.modified_files }}; do
          json_content=$(yq eval "$file" -o=json)            
          json_file="${file%.yml}.json"
          echo "$json_content" > "$json_file"
          modified_files+=("$json_file")
          done
          fi
          echo "::set-output name=added_json::${added_files[@]}"
          echo "::set-output name=modified_json::${modified_files[@]}"

      - name: Convert json files to payload json
        id: parse-payload
        run: |
          payload_files=()
          # For added files
          echo "${{ steps.transform-yaml-to-json.outputs.added_json }}"
          echo "${{ steps.transform-yaml-to-json.outputs.modified_json }}"

          if [[ -n "${{ steps.transform-yaml-to-json.outputs.added_json }}" ]]; then
            IFS=' ' read -ra added_files <<< "${{ steps.transform-yaml-to-json.outputs.added_json }}"
            for file in "${added_files[@]}"; do
              echo "${file}"
              json_content=$(cat "$file")
              echo "ADDED ${json_content}"
              event_payload=$(echo "$json_content" | jq -c '{"action": "CREATE", "payload": {"jobId": .metadata.id,"name":.metadata.name,"version":.metadata.version,"notValidAfter":.metadata.notValidAfter,"notValidBefore":.metadata.notValidBefore,"usageDataQueries":.spec.needsUsageData,"costDataQueries":.spec.costDataQueries,"calculationQuery":.spec.calculationQuery,"active":.metadata.active,"dryRun":.metadata.dryRun}}')
              payload_files+=("$event_payload")
            done
          fi

          # For modified files
          if [[ -n "${{ steps.transform-yaml-to-json.outputs.modified_json }}" ]]; then
            IFS=' ' read -ra modified_files <<< "${{ steps.transform-yaml-to-json.outputs.modified_json }}"
            for file in "${modified_files[@]}"; do       
              echo "${file}"
              json_content=$(cat "$file")
              echo "UPDATED ${json_content}"
              event_payload=$(echo "$json_content" | jq -c '{"action": "UPDATE", "payload": {"jobId": .metadata.id,"name":.metadata.name,"version":.metadata.version,"notValidAfter":.metadata.notValidAfter,"notValidBefore":.metadata.notValidBefore,"usageDataQueries":.spec.needsUsageData,"costDataQueries":.spec.costDataQueries,"calculationQuery":.spec.calculationQuery,"active":.metadata.active,"dryRun":.metadata.dryRun}}')
              payload_files+=("$event_payload")
            done
          fi

          echo "${payload_files[@]}"  # Print all payloads in the array
          echo "::set-output name=payload_json_array::${payload_files[@]}"

      - name: Use JSON Array Output
        run: |
          # Iterate over the array of JSON files
          for file in "${{ steps.parse-payload.outputs.payload_json_array[@] }}"; do
            echo "Processing file: $file"

            # You can use $file as the path to the JSON file in your logic
            # For example, printing the content of the file
            cat "$file"
          done
      # - name: Echo CREATE LAMBDA
      #   if: steps.changed-files.outputs.modified_files_count != '0'
      #   run: |
      #     echo CREATE LAMBDA
      # - name: Echo UPDATE LAMBDA
      #   if: steps.changed-files.outputs.modified_files_count == '0'
      #   run: |
      #     echo UPDATE LAMBDA
      # - name: Configure AWS creds
      #   uses: aws-actions/configure-aws-credentials@v3
      #   with:
      #     role-to-assume: arn:aws:iam::${{ inputs.account-id }}:role/github-actions-service-catalog-metering
      #     role-session-name: deploysession
      #     aws-region: us-east-1
      # - name: Invoke AWS Lambda Function
      #   if: ${{ inputs.payload == 'Clear Synchronizer execution history table' || inputs.payload == 'Clear all' }}
      #   run: |
      #     aws lambda invoke \
      #     --function-name gsm-qacleanup-${{ fromJSON(steps.environment.outputs.data).environment_short_name }}-CleanUp \
      #     --cli-binary-format raw-in-base64-out \
      #     --payload file://payload.json \
      #     response.json
